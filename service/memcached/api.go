// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package memcached

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/request"
)

const opCreateCacheCluster = "CreateCacheCluster"

// CreateCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the CreateCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateCacheCluster for more information on using the CreateCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateCacheClusterRequest method.
//    req, resp := client.CreateCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/CreateCacheCluster
func (c *Memcached) CreateCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opCreateCacheCluster,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// CreateCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation CreateCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/CreateCacheCluster
func (c *Memcached) CreateCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.CreateCacheClusterRequest(input)
	return out, req.Send()
}

// CreateCacheClusterWithContext is the same as CreateCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See CreateCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) CreateCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.CreateCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteCacheCluster = "DeleteCacheCluster"

// DeleteCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the DeleteCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteCacheCluster for more information on using the DeleteCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteCacheClusterRequest method.
//    req, resp := client.DeleteCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DeleteCacheCluster
func (c *Memcached) DeleteCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDeleteCacheCluster,
		HTTPMethod: "DELETE",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DeleteCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DeleteCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DeleteCacheCluster
func (c *Memcached) DeleteCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DeleteCacheClusterRequest(input)
	return out, req.Send()
}

// DeleteCacheClusterWithContext is the same as DeleteCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DeleteCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DeleteCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteCacheSecurityRule = "DeleteCacheSecurityRule"

// DeleteCacheSecurityRuleRequest generates a "ksc/request.Request" representing the
// client's request for the DeleteCacheSecurityRule operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteCacheSecurityRule for more information on using the DeleteCacheSecurityRule
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteCacheSecurityRuleRequest method.
//    req, resp := client.DeleteCacheSecurityRuleRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DeleteCacheSecurityRule
func (c *Memcached) DeleteCacheSecurityRuleRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDeleteCacheSecurityRule,
		HTTPMethod: "DELETE",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DeleteCacheSecurityRule API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DeleteCacheSecurityRule for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DeleteCacheSecurityRule
func (c *Memcached) DeleteCacheSecurityRule(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DeleteCacheSecurityRuleRequest(input)
	return out, req.Send()
}

// DeleteCacheSecurityRuleWithContext is the same as DeleteCacheSecurityRule with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteCacheSecurityRule for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DeleteCacheSecurityRuleWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DeleteCacheSecurityRuleRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeAvailabilityZones = "DescribeAvailabilityZones"

// DescribeAvailabilityZonesRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeAvailabilityZones operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeAvailabilityZones for more information on using the DescribeAvailabilityZones
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeAvailabilityZonesRequest method.
//    req, resp := client.DescribeAvailabilityZonesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeAvailabilityZones
func (c *Memcached) DescribeAvailabilityZonesRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeAvailabilityZones,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeAvailabilityZones API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DescribeAvailabilityZones for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeAvailabilityZones
func (c *Memcached) DescribeAvailabilityZones(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeAvailabilityZonesRequest(input)
	return out, req.Send()
}

// DescribeAvailabilityZonesWithContext is the same as DescribeAvailabilityZones with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeAvailabilityZones for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DescribeAvailabilityZonesWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeAvailabilityZonesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeCacheCluster = "DescribeCacheCluster"

// DescribeCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeCacheCluster for more information on using the DescribeCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeCacheClusterRequest method.
//    req, resp := client.DescribeCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheCluster
func (c *Memcached) DescribeCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeCacheCluster,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DescribeCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheCluster
func (c *Memcached) DescribeCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheClusterRequest(input)
	return out, req.Send()
}

// DescribeCacheClusterWithContext is the same as DescribeCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DescribeCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeCacheClusters = "DescribeCacheClusters"

// DescribeCacheClustersRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeCacheClusters operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeCacheClusters for more information on using the DescribeCacheClusters
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeCacheClustersRequest method.
//    req, resp := client.DescribeCacheClustersRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheClusters
func (c *Memcached) DescribeCacheClustersRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeCacheClusters,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeCacheClusters API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DescribeCacheClusters for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheClusters
func (c *Memcached) DescribeCacheClusters(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheClustersRequest(input)
	return out, req.Send()
}

// DescribeCacheClustersWithContext is the same as DescribeCacheClusters with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeCacheClusters for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DescribeCacheClustersWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheClustersRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeCacheSecurityRules = "DescribeCacheSecurityRules"

// DescribeCacheSecurityRulesRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeCacheSecurityRules operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeCacheSecurityRules for more information on using the DescribeCacheSecurityRules
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeCacheSecurityRulesRequest method.
//    req, resp := client.DescribeCacheSecurityRulesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheSecurityRules
func (c *Memcached) DescribeCacheSecurityRulesRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeCacheSecurityRules,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeCacheSecurityRules API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DescribeCacheSecurityRules for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeCacheSecurityRules
func (c *Memcached) DescribeCacheSecurityRules(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheSecurityRulesRequest(input)
	return out, req.Send()
}

// DescribeCacheSecurityRulesWithContext is the same as DescribeCacheSecurityRules with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeCacheSecurityRules for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DescribeCacheSecurityRulesWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeCacheSecurityRulesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeRegions = "DescribeRegions"

// DescribeRegionsRequest generates a "ksc/request.Request" representing the
// client's request for the DescribeRegions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeRegions for more information on using the DescribeRegions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeRegionsRequest method.
//    req, resp := client.DescribeRegionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeRegions
func (c *Memcached) DescribeRegionsRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opDescribeRegions,
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// DescribeRegions API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation DescribeRegions for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/DescribeRegions
func (c *Memcached) DescribeRegions(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.DescribeRegionsRequest(input)
	return out, req.Send()
}

// DescribeRegionsWithContext is the same as DescribeRegions with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeRegions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) DescribeRegionsWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.DescribeRegionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opFlushCacheCluster = "FlushCacheCluster"

// FlushCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the FlushCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See FlushCacheCluster for more information on using the FlushCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the FlushCacheClusterRequest method.
//    req, resp := client.FlushCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/FlushCacheCluster
func (c *Memcached) FlushCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opFlushCacheCluster,
		HTTPMethod: "PUT",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// FlushCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation FlushCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/FlushCacheCluster
func (c *Memcached) FlushCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.FlushCacheClusterRequest(input)
	return out, req.Send()
}

// FlushCacheClusterWithContext is the same as FlushCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See FlushCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) FlushCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.FlushCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opRenameCacheCluster = "RenameCacheCluster"

// RenameCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the RenameCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See RenameCacheCluster for more information on using the RenameCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the RenameCacheClusterRequest method.
//    req, resp := client.RenameCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/RenameCacheCluster
func (c *Memcached) RenameCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opRenameCacheCluster,
		HTTPMethod: "PUT",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// RenameCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation RenameCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/RenameCacheCluster
func (c *Memcached) RenameCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.RenameCacheClusterRequest(input)
	return out, req.Send()
}

// RenameCacheClusterWithContext is the same as RenameCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See RenameCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) RenameCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.RenameCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opResizeCacheCluster = "ResizeCacheCluster"

// ResizeCacheClusterRequest generates a "ksc/request.Request" representing the
// client's request for the ResizeCacheCluster operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ResizeCacheCluster for more information on using the ResizeCacheCluster
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ResizeCacheClusterRequest method.
//    req, resp := client.ResizeCacheClusterRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/ResizeCacheCluster
func (c *Memcached) ResizeCacheClusterRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opResizeCacheCluster,
		HTTPMethod: "PUT",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// ResizeCacheCluster API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation ResizeCacheCluster for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/ResizeCacheCluster
func (c *Memcached) ResizeCacheCluster(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.ResizeCacheClusterRequest(input)
	return out, req.Send()
}

// ResizeCacheClusterWithContext is the same as ResizeCacheCluster with the addition of
// the ability to pass a context and additional request options.
//
// See ResizeCacheCluster for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) ResizeCacheClusterWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.ResizeCacheClusterRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opSetCacheSecurityRules = "SetCacheSecurityRules"

// SetCacheSecurityRulesRequest generates a "ksc/request.Request" representing the
// client's request for the SetCacheSecurityRules operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See SetCacheSecurityRules for more information on using the SetCacheSecurityRules
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the SetCacheSecurityRulesRequest method.
//    req, resp := client.SetCacheSecurityRulesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/SetCacheSecurityRules
func (c *Memcached) SetCacheSecurityRulesRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opSetCacheSecurityRules,
		HTTPMethod: "PUT",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// SetCacheSecurityRules API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation SetCacheSecurityRules for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/SetCacheSecurityRules
func (c *Memcached) SetCacheSecurityRules(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.SetCacheSecurityRulesRequest(input)
	return out, req.Send()
}

// SetCacheSecurityRulesWithContext is the same as SetCacheSecurityRules with the addition of
// the ability to pass a context and additional request options.
//
// See SetCacheSecurityRules for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) SetCacheSecurityRulesWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.SetCacheSecurityRulesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePassword = "UpdatePassword"

// UpdatePasswordRequest generates a "ksc/request.Request" representing the
// client's request for the UpdatePassword operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePassword for more information on using the UpdatePassword
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePasswordRequest method.
//    req, resp := client.UpdatePasswordRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/UpdatePassword
func (c *Memcached) UpdatePasswordRequest(input *map[string]interface{}) (req *request.Request, output *map[string]interface{}) {
	op := &request.Operation{
		Name:       opUpdatePassword,
		HTTPMethod: "PUT",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &map[string]interface{}{}
	}

	output = &map[string]interface{}{}
	req = c.newRequest(op, input, output)

	return
}

// UpdatePassword API operation for memcached.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the KSC API reference guide for memcached's
// API operation UpdatePassword for usage and error information.
// See also, https://docs.aws.amazon.com/goto/WebAPI/memcached-2018-06-27/UpdatePassword
func (c *Memcached) UpdatePassword(input *map[string]interface{}) (*map[string]interface{}, error) {
	req, out := c.UpdatePasswordRequest(input)
	return out, req.Send()
}

// UpdatePasswordWithContext is the same as UpdatePassword with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePassword for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Memcached) UpdatePasswordWithContext(ctx aws.Context, input *map[string]interface{}, opts ...request.Option) (*map[string]interface{}, error) {
	req, out := c.UpdatePasswordRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
